/*
    bits[0]: xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx - младшие
    bits[1]: xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx - средние
    bits[2]: xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx - старшие
    bits[3]: x0000000 xxxxxxxx 00000000 00000000 - служебные
           0b00000000000000000000000000000000

    0 — OK;
    1 — число слишком велико или равно бесконечности;
    2 — число слишком мало или равно отрицательной бесконечности;
    3 — деление на 0.

    UintMax = 4294967295
    intMax = 2147483647

    decimalMax = 79 228 162 514 264 337 593 543 950 335
*/

/*
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
*/

/*
  Алгоритм сложения:

  123,8959 => scale = 4; mantissa = 1238959
  5494,87  => scale = 2; mantissa = 549487

  diff scale = 4 - 2 = 2

  Number with min scale *= 10^diff scale => 549487 * 10^2 = 54948700

  Произвожу сложение:
     1238959
   +54948700
    56187659 = mantissa

  Делаю обратный scale: scale = MaxScale = 4 => 5618,7659

*/

/*
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00001000 00000000
  11111111 11110011 11111111 11111111

  shift = 3:

  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 01000000 00000111
  11111111 10011111 11111111 11111000

*/

/*
  Алгоритм умножения на 10:

    a * 10 = a * 8 + a * 2 = a << 3 + a << 1;

    a << i: нужно битово сдвинуть влево есть ограничение по ячейкам массива (там
  же инты) Взять последнии i бит инта и перенести их вначало следующего инта, а
  предыдущий инт битово сдвинуть
*/

/*
  1256.879 =  1256 879
  98492.1  = 98492 100
           = 99748.979
*/

/*
  79 228 162 514 264 337 593 543 950 335
    scale = 5
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111
= 79 228 162 514 264 337 593 543 9.50 335

    scale = 1
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000
  11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111
         792 281 625 142 643 375 935 439.50 335
=  7 922 816 251 426 433 759 354 395 033.5

       79 228 162 514 264 337 593 543 950 335
 +792 281 625 142 643 375 935 439 503 350 000
 =7923608533051576392720330473
 79228162514264337593543950335
+++++


  делить до тех пор, пока не дойду до maxScale (если старшие биты всё ещё
заполнены, а мы еще не дошли до max скейл, то это переполнение ) (однако надо
проверить, вдруг округление даст нормальное число и переполнения не будет)

   7 923 608 533 051 576 402 730 330 473.0 033 5
  79 228 162 514 264 337 593 543 950 335
*/

/*
  11111111 11111111 11111111 11111000 + 11111111 11111111 11111111 11111110 =
  11111111 11111111 11111111 11110110 00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000   00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000   00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000000   00000000 00000000 00000000 00000000
  00000000 00000000 00000000 00000111   00000000 00000000 00000000 00000001
  00000000 00000000 00000000 00001001 11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111   11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111   11111111 11111111 11111111 11111111
  11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111000
  11111111 11111111 11111111 11111110   11111111 11111111 11111111 11110110

*/

/*
79 228 162 514 264 337 593 543 950 335

79228162514264337593543950335 scale = 0
7.9228162514264337593543950335 scals = 28

792281625142643375935439503350000000000000000000000000000
000000000000000000000000000079228162514264337593543950335

79228162514264337593543950342.9228162514264337593543950335
79228162514264337593543950335
*/

/*
79228162514264337593543950330 scale = 0
5.7 scale = 1

792281625142643375935439503300
000000000000000000000000000057

79228162514264337593543950336
79228162514264337593543950335
*/

/*
  79228162514264337593543950330
  2.75

  7922816251426433759354395033000
  0000000000000000000000000000275
  7922816251426433759354395033275 -> 792281625142643375935439503328 ->
  79228162514264337593543950333 div = + 79228162514264337593543950335

    79228162514264337593543950335
*/

/*
  45 * 6 = 270

     101101
 *      110
 =100001110

  110 * 2^0 + 110 * 2^2 + 110 * 2^3 + 110 * 2^5 = 110 + 11000 + 110000 +
 11000000 =

  11000000
    110000
     11000
       110
 100001110

  45 * 6 = 270
  4.5 * 6 = 27
  0.45 * 6 = 2.7
  4.5 * 0.6 = 2.7

  151 * 24 = 3624
  15.1 * 24 = 362.4
  1.51 * 24 = 36.24
  1.51 * 2.4 = 3.624
*/

/*
  2 = 0000010
  1 = 0000001

  1 - 2 = 1 + ~2

  00000001
  11111101
  11111110 - обратный код
  00000001 - прямой код

  2 - 1 = 1;

  00000010
 +11111110
  00000000 - неверный обратный код
  +1 - верный доп код
*/

/*
  10 / 4 = 2.5



  0.15 / 0.3 = 0.5
  15 / 3 = 5
  2 - 1 = 1 - scale
*/

/*
    3   -10     00000011            Меньшее - Большее
  -10  +  3    +11110101
   -7    -7     11111000 = 7 (в обр коде) (-7) -> 00000111



  -3   10      00001010            Большее - Меньшее
 +10   -3     +11111100
   7    7    1 00000110 = 6 (но переполнение) (прямой код на один меньше) ->
 00000111


  У отрицательного числа - обратный код



  -A - -B = B - A (B > A || A > B)
                 + B - A  - A - B
  +A - +B = A - B (B > A || A > B)
                 - B - A  + A - B

  if (sign)

*/

/*

7 / 3 = 2,33333

  7 = 0111
  3 = 0011

  0011 = 3
 +1000 = 7 (обр)
  1011 (обр) = 0100 = 4     остаток = 7

  0011 = 3
 +1011 = 4 (обр)
  1110 (обр) = 0001 = 1      остаток = 4

  0001 = 1
 +1100 = 3 (обр)
  1101 (обр) = 0010 = 2 (знак -) = -2      остаток = 1

  целая часть = 3 - 1 = 2

  1 * 10 = 10
  10 / 3 = 3; remain = 1

  10 = 2 * 4 + 2

  0.15 / 0.3 = 0.5

  15 / 3 = 5
  scale = 2 - 1 = 1

*/

/*
    Деление:
        Метод бинарного поиска
        Деление в столбик с использованием сдвига

    Сколько раз делитель помещается в текущей части делимого
    и вычитать сразу умноженный делитель на это количество.

    На каждом шаге определить максимальную степень двойки, на которую можно
    умножить делитель, чтобы он поместился в остатке, и затем вычитать этот
    умноженный делить из остатка, добавляя соответствующую степень к результату.

    Нормализация - делитель максимально возможный, но меньше делимого

    def divide(a, b):
    quotient = 0
    remainder = 0
    for i in range(95, -1, -1):
        remainder = (remainder << 1) | ((a >> i) & 1)
        if remainder >= b:
            remainder -= b
            quotient |= 1 << i
    return quotient, remainder
*/

/*
    s21_decimal remain = 0;
    s21_decimal q = 0; частное

    for (int i = 255; i >= 0; --i) {
        remain = remain << 1 | s21_isSetBit(value_1, i);

        if (remain >= value_2) {
            s21_sub(remain, value_2, &remain);

            q.bits[i / 32] |= s21_setBit(1, i % 32);
        }
    }


    111010010
    010010100
*/